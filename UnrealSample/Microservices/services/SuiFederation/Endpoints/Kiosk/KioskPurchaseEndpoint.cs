using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Inventory;
using Beamable.Server;
using Beamable.Server.Content;
using Beamable.SuiFederation.Extensions;
using Beamable.SuiFederation.Features.Accounts;
using Beamable.SuiFederation.Features.ChannelProcessor;
using Beamable.SuiFederation.Features.Contract;
using Beamable.SuiFederation.Features.Contract.Storage.Models;
using Beamable.SuiFederation.Features.Inventory;
using Beamable.SuiFederation.Features.Kiosk;
using Beamable.SuiFederation.Features.Kiosk.Exceptions;
using Beamable.SuiFederation.Features.Kiosk.Models;
using Beamable.SuiFederation.Features.Kiosk.Storage;
using Beamable.SuiFederation.Features.Kiosk.Storage.Models;
using Beamable.SuiFederation.Features.Transactions;
using SuiFederationCommon;
using SuiFederationCommon.Extensions;
using SuiFederationCommon.FederationContent;
using SuiFederationCommon.Models.Kiosk;
using SuiFederationCommon.Models.Notifications;
using KioskListing = Beamable.SuiFederation.Features.Kiosk.Storage.Models.KioskListing;
using KioskListingStatus = Beamable.SuiFederation.Features.Kiosk.Storage.Models.KioskListingStatus;

namespace Beamable.SuiFederation.Endpoints.Kiosk;

public class KioskPurchaseEndpoint : IEndpoint
{
    private readonly RequestContext _requestContext;
    private readonly ContractService _contractService;
    private readonly InventoryApi _inventoryApi;
    private readonly TransactionManager _transactionManager;
    private readonly AccountsService _accountsService;
    private readonly KioskListingCollection _kioskListingCollection;
    private readonly KioskHandlerFactory _kioskHandlerFactory;
    private readonly UpdatePlayerStateService _updatePlayerStateService;
    private readonly GetInventoryStateEndpoint _getInventoryStateEndpoint;

    public KioskPurchaseEndpoint(RequestContext requestContext, ContractService contractService, InventoryApi inventoryApi, TransactionManager transactionManager, AccountsService accountsService, KioskListingCollection kioskListingCollection, KioskHandlerFactory kioskHandlerFactory, UpdatePlayerStateService updatePlayerStateService, GetInventoryStateEndpoint getInventoryStateEndpoint)
    {
        _requestContext = requestContext;
        _contractService = contractService;
        _inventoryApi = inventoryApi;
        _transactionManager = transactionManager;
        _accountsService = accountsService;
        _kioskListingCollection = kioskListingCollection;
        _kioskHandlerFactory = kioskHandlerFactory;
        _updatePlayerStateService = updatePlayerStateService;
        _getInventoryStateEndpoint = getInventoryStateEndpoint;
    }

    public async Task<KioskPurchaseResponse> Purchase(string listingId)
    {
        var listing = await _kioskListingCollection.GetByListingId(listingId);
        var items = await _inventoryApi.ObjectGet(_requestContext.UserId);
        var validateResult = ValidateRequest(items, listing);
        var wallet = await _accountsService.GetWallet(_requestContext.UserId, validateResult.Identity);
        var kioskContract = await _contractService.GetKioskContract(listing.ItemContentId.ToContentType(), listing.PriceContentId);
        var currencyContract = await _contractService.GetByContentId<ContractBase>(listing.PriceContentId);
        var handler = _kioskHandlerFactory.GetHandler(validateResult.Identity);

        var kioskTransactionId = new KioskTransactionId();
        var transactionId = await _transactionManager.StartTransaction(wallet, nameof(Purchase), kioskTransactionId, new {listing.ItemContentId, listing.ItemProxyId, listing.ListingId});
        _transactionManager.SetCurrentTransactionContext(transactionId);
        _ = _transactionManager.RunAsyncBlock(transactionId, kioskTransactionId, async () =>
        {
            await ChannelService.Enqueue(_requestContext.UserId, async (_) =>
                await handler.PurchaseFromSale(new KioskPurchaseModel(_requestContext.UserId, wallet, listing.ListingId, listing.Price, kioskContract, currencyContract, transactionId.ToString()))
            );

            await ChannelService.Enqueue(_requestContext.UserId, async (_) =>
                await _updatePlayerStateService.Update(new KioskNotification
                {
                    Id = kioskTransactionId
                }, _getInventoryStateEndpoint, validateResult.Identity)
            );

            await ChannelService.Enqueue(listing.GamerTag, async (_) =>
                await _updatePlayerStateService.Update(listing.GamerTag, _getInventoryStateEndpoint, validateResult.Identity)
            );
        });

        return new KioskPurchaseResponse();
    }

    private ValidationResult ValidateRequest(InventoryView items, KioskListing listing)
    {
        if (listing.Status != KioskListingStatus.Active)
            throw new KioskException($"Item with inventory ID {listing.ItemInventoryId} is not actively listed on the kiosk.");

        var currencyResult = items.currencies.FirstOrDefault(c => c.id == listing.PriceContentId);
        if (currencyResult is null || currencyResult.amount < listing.Price)
            throw new KioskException($"Insufficient funds to purchase item with listing {listing.ListingId}.");

        return new ValidationResult(new MicroserviceInfo(SuiFederationSettings.MicroserviceName, listing.Namespace));
    }

    private readonly record struct ValidationResult(MicroserviceInfo Identity);
}
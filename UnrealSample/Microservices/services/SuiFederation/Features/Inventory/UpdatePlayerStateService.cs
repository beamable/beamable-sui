using System;
using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.SuiFederation.Endpoints;
using Beamable.SuiFederation.Extensions;
using Beamable.SuiFederation.Features.Accounts;
using Beamable.SuiFederation.Features.Notifications;
using Beamable.SuiFederation.Features.Transactions.Storage;
using SuiFederationCommon.Models.Notifications;

namespace Beamable.SuiFederation.Features.Inventory;

public class UpdatePlayerStateService : IService
{
    private readonly AccountsService _accountsService;
    private readonly IBeamableRequester _beamableRequester;
    private readonly TransactionLogCollection _transactionLogCollection;
    private readonly PlayerNotificationService _playerNotificationService;
    private readonly Configuration _configuration;

    public UpdatePlayerStateService(AccountsService accountsService, IBeamableRequester beamableRequester, TransactionLogCollection transactionLogCollection, PlayerNotificationService playerNotificationService, Configuration configuration)
    {
        _accountsService = accountsService;
        _beamableRequester = beamableRequester;
        _transactionLogCollection = transactionLogCollection;
        _playerNotificationService = playerNotificationService;
        _configuration = configuration;
    }

    public async Task Update(IPlayerNotification notification, GetInventoryStateEndpoint inventoryStateEndpoint, MicroserviceInfo microserviceInfo)
    {
        try
        {
            var transactionLog = await _transactionLogCollection.GetByInventoryTransaction(notification.Id);
            if (transactionLog is not null && transactionLog.MintedTimestamp is null)
            {
                await _transactionLogCollection.SetMintedDone(transactionLog.Id);
                var gamerTag = await GetGamerTag(transactionLog.Wallet);
                if (gamerTag == 0)
                    gamerTag = transactionLog.RequesterUserId;
                await SynchronizeState(gamerTag, transactionLog.Wallet, inventoryStateEndpoint, microserviceInfo);
                await _playerNotificationService.SendPlayerNotification(gamerTag, notification);
            }
        }
        catch (Exception e)
        {
            BeamableLogger.LogException(e);
        }
    }

    public async Task Update(long gamerTag, GetInventoryStateEndpoint inventoryStateEndpoint, MicroserviceInfo microserviceInfo)
    {
        try
        {
            var wallet = await _accountsService.GetWallet(gamerTag, microserviceInfo);
            await SynchronizeState(gamerTag, wallet, inventoryStateEndpoint, microserviceInfo);
        }
        catch (Exception e)
        {
            BeamableLogger.LogException(e);
        }
    }

    private async Task SynchronizeState(long gamerTag, string walletAddress, GetInventoryStateEndpoint inventoryStateEndpoint, MicroserviceInfo microserviceInfo)
    {
        try
        {
            await Task.Delay(TimeSpan.FromSeconds(await _configuration.TransactionDelaySec));
            BeamableLogger.Log("Synchronize state for user {gamerTag} with external info {microserviceInfo}", gamerTag, microserviceInfo);
            var existingExternalIdentity = microserviceInfo.ToExternalIdentity();
            var newState = await inventoryStateEndpoint.GetInventoryState(walletAddress, existingExternalIdentity);
            await _beamableRequester.Request<CommonResponse>(Method.PUT, $"/object/inventory/{gamerTag}/proxy/state", newState, includeAuthHeader: false);
        }
        catch (Exception e)
        {
            BeamableLogger.LogError("Error synchronizing inventory for user {gamerTag}, wallet {w}", gamerTag, walletAddress);
            BeamableLogger.LogError(e);
        }
    }

    private async Task<long> GetGamerTag(string walletAddress)
    {
        var account = await _accountsService.SearchAccount(walletAddress);
        if (account is null)
        {
            BeamableLogger.LogError("Account not found for wallet {address}", walletAddress);
            return 0;
        }

        var gamerTag = account.gamerTags
            .Where(x => x.projectId == _beamableRequester.Pid)
            .Select(x => x.gamerTag)
            .FirstOrDefault();

        if (gamerTag == 0)
        {
            BeamableLogger.LogError("Can't find a gamerTag on project {pid} for account {aid}", _beamableRequester.Pid, account.id);
        }

        return gamerTag;
    }
}
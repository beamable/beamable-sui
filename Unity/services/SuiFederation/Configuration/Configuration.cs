using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Realms;
using Beamable.Common;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;
using Beamable.SuiFederation.Extensions;

namespace Beamable.SuiFederation;

public class Configuration : IService
{
    private const string ConfigurationNamespace = "sui-federation";
    private readonly IRealmConfigService _realmConfigService;
    private readonly RealmsApi _realmsApi;

    public readonly string RealmSecret = Environment.GetEnvironmentVariable("SECRET") ?? "";
    private RealmConfig? _realmConfig;

    public Configuration(IRealmConfigService realmConfigService, SocketRequesterContext socketRequesterContext, RealmsApi realmsApi)
    {
        _realmConfigService = realmConfigService;
        _realmsApi = realmsApi;
        socketRequesterContext.Subscribe<object>(Constants.Features.Services.REALM_CONFIG_UPDATE_EVENT, _ =>
        {
            BeamableLogger.Log("Realm config was updated");
            _realmConfig = null;
        });
    }

    /// <summary>
    /// CONFIG VALUES
    /// To configure an explicit configuration values, visit the Beamable portal and add configuration under Operate -> Config.
    /// Configuration namespace is configured in the <see cref="ConfigurationNamespace"/> constant.
    /// </summary>

    public ValueTask<string> SuiEnvironment => GetValue(nameof(SuiEnvironment), "devnet");
    public ValueTask<int> AuthenticationChallengeTtlSec => GetValue(nameof(AuthenticationChallengeTtlSec), 600);
    public ValueTask<int> NumberOfWorkingWallets => GetValue(nameof(NumberOfWorkingWallets), 10);
    public ValueTask<int> MaxNumberOffWorkingWallets => GetValue(nameof(MaxNumberOffWorkingWallets), 100);
    public ValueTask<long> SuiCoinMinimalAmountMist => GetValue<long>(nameof(SuiCoinMinimalAmountMist), SuiExtensions.MistPerSui);
    public ValueTask<int> CoinTransferPercentage => GetValue(nameof(CoinTransferPercentage), 30);
    public ValueTask<int> TransactionDelaySec => GetValue(nameof(TransactionDelaySec), 2);
    public ValueTask<string> EnokiApiKey => GetValue(nameof(EnokiApiKey), "");
    public ValueTask<string> EnokiUrl => GetValue(nameof(EnokiUrl), "");
    public ValueTask<int> EnokiZkAdditionalEpochs => GetValue(nameof(EnokiZkAdditionalEpochs), 30);
    public ValueTask<string> GoogleClientSecret => GetValue(nameof(GoogleClientSecret), "");
    public ValueTask<string> TwitchClientSecret => GetValue(nameof(TwitchClientSecret), "");
    public ValueTask<bool> UsePersonalKiosk => GetValue(nameof(UsePersonalKiosk), true);

    private async ValueTask<T> GetValue<T>(string key, T defaultValue) where T : IConvertible
    {
        _realmConfig ??= await _realmConfigService.GetRealmConfigSettings();
        var namespaceConfig = _realmConfig!.GetValueOrDefault(ConfigurationNamespace) ?? new ReadOnlyDictionary<string, string>(new Dictionary<string, string>());
        var value = namespaceConfig.GetValueOrDefault(key);
        if (value is null)
        {
            return defaultValue;
        }
        return (T)Convert.ChangeType(value, typeof(T));
    }

    public async Task Update(string name, string value)
    {
        var currentConfig = await _realmsApi.GetConfig();
        currentConfig.config[$"{ConfigurationNamespace}|{name}"] = value;
        await _realmsApi.PutConfig(new RealmConfigSaveRequest
        {
            config = currentConfig.config
        });
    }
}

internal class ConfigurationException(string message)
    : MicroserviceException((int)HttpStatusCode.BadRequest, "ConfigurationError", message);
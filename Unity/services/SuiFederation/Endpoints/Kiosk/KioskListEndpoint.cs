using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Inventory;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common.Inventory;
using Beamable.Server;
using Beamable.Server.Content;
using Beamable.SuiFederation.Extensions;
using Beamable.SuiFederation.Features.Accounts;
using Beamable.SuiFederation.Features.ChannelProcessor;
using Beamable.SuiFederation.Features.Contract;
using Beamable.SuiFederation.Features.Contract.Handlers;
using Beamable.SuiFederation.Features.Contract.Storage.Models;
using Beamable.SuiFederation.Features.Inventory;
using Beamable.SuiFederation.Features.Kiosk;
using Beamable.SuiFederation.Features.Kiosk.Exceptions;
using Beamable.SuiFederation.Features.Kiosk.Models;
using Beamable.SuiFederation.Features.Kiosk.Storage;
using Beamable.SuiFederation.Features.Transactions;
using SuiFederationCommon.Extensions;
using SuiFederationCommon.FederationContent;
using SuiFederationCommon.Models.Kiosk;
using SuiFederationCommon.Models.Notifications;

namespace Beamable.SuiFederation.Endpoints.Kiosk;

public class KioskListEndpoint : IEndpoint
{
    private readonly RequestContext _requestContext;
    private readonly ContractService _contractService;
    private readonly InventoryApi _inventoryApi;
    private readonly ContentService _contentService;
    private readonly TransactionManager _transactionManager;
    private readonly AccountsService _accountsService;
    private readonly KioskHandlerFactory _kioskHandlerFactory;
    private readonly UpdatePlayerStateService _updatePlayerStateService;
    private readonly GetInventoryStateEndpoint _getInventoryStateEndpoint;
    private readonly PersonalKioskCollection _personalKioskCollection;

    public KioskListEndpoint(ContractService contractService, RequestContext requestContext, InventoryApi inventoryApi, ContentService contentService, TransactionManager transactionManager, AccountsService accountsService, KioskHandlerFactory kioskHandlerFactory, UpdatePlayerStateService updatePlayerStateService, GetInventoryStateEndpoint getInventoryStateEndpoint, PersonalKioskCollection personalKioskCollection)
    {
        _contractService = contractService;
        _requestContext = requestContext;
        _inventoryApi = inventoryApi;
        _contentService = contentService;
        _transactionManager = transactionManager;
        _accountsService = accountsService;
        _kioskHandlerFactory = kioskHandlerFactory;
        _updatePlayerStateService = updatePlayerStateService;
        _getInventoryStateEndpoint = getInventoryStateEndpoint;
        _personalKioskCollection = personalKioskCollection;
    }

    public async Task ListForSale(long itemId, long price, string optionalKioskContentId)
    {
        var items = await _inventoryApi.ObjectGet(_requestContext.UserId);
        var validationResult = await ValidateRequest(itemId, optionalKioskContentId, price, items);
        var wallet = await _accountsService.GetWallet(_requestContext.UserId, validationResult.Identity);

        var itemContract = await _contractService.GetByContentId<NftContract>(validationResult.ItemContentId.ToContentType());
        var kioskContract = await _contractService.GetKioskContract(validationResult.ItemContentId.ToContentType(), validationResult.PriceContentId);

        var handler = _kioskHandlerFactory.GetHandler(validationResult.Identity);
        var kioskTransactionId = new KioskTransactionId();
        var transactionId = await _transactionManager.StartTransaction(wallet, nameof(ListForSale), kioskTransactionId, new {validationResult.ItemContentId, validationResult.PriceContentId, price});
        _transactionManager.SetCurrentTransactionContext(transactionId);
        _ = _transactionManager.RunAsyncBlock(transactionId, kioskTransactionId, async () =>
        {
            await ChannelService.Enqueue(_requestContext.UserId, async (_) =>
                await handler.ListForSale(new KioskListModel(_requestContext.UserId, wallet, itemContract, kioskContract, validationResult.KioskItem, itemId, validationResult.ItemContentId, validationResult.ItemProxyId, price, transactionId.ToString(), validationResult.Identity.MicroserviceNamespace))
            );

            await ChannelService.Enqueue(_requestContext.UserId, async (_) =>
                await _updatePlayerStateService.Update(new KioskNotification
                {
                    Id = kioskTransactionId
                }, _getInventoryStateEndpoint, validationResult.Identity)
            );
        });
    }

    private async Task<ValidationResult> ValidateRequest(long itemId, string optionalKioskContentId, long price, InventoryView items)
    {
        if (price <= 0)
            throw new KioskException("Price must be greater than zero.");

        var itemResult = items.items
            .SelectMany(g => g.items, (g, i) => new { GroupId = g.id, Item = i, Proxy = i.proxy.Value })
            .FirstOrDefault(x => x.Item.id == itemId && x.Item.proxy.HasValue);
        if (itemResult is null)
            throw new KioskException($"Item with id {itemId} does not exist in the inventory.");

        if (string.IsNullOrWhiteSpace(optionalKioskContentId))
        {
            var definedKioskContent = await _contractService.FetchFederationContentForKioskContracts();
            var targetKiosk = definedKioskContent.FirstOrDefault(k => k.Kiosk.ItemType == itemResult.GroupId.ToContentType());
            if (targetKiosk is null)
                throw new KioskException($"No default kiosk is defined for item content id {itemResult.GroupId}.");
            optionalKioskContentId = targetKiosk.Kiosk.Id;
        }

        var kioskContentData = await _contentService.GetContent(optionalKioskContentId);
        if (kioskContentData is not KioskItem kioskContent)
            throw new KioskException($"Kiosk content id {optionalKioskContentId} is not valid.");

        var currencyContentData = await _contentService.GetContent(kioskContent.CurrencySymbol);
        if (currencyContentData is not CurrencyContent currencyContent)
            throw new KioskException($"Price content id {kioskContent.CurrencySymbol} is not a valid currency.");

        if (!currencyContent.federation.HasValue)
            throw new KioskException($"Price content id {currencyContent.Id} is not federated.");

        return new ValidationResult(itemResult.GroupId, currencyContent.Id, itemResult.Item.proxyId.Value, kioskContent, new MicroserviceInfo(itemResult.Proxy.service, itemResult.Proxy.namespaceKey));
    }

    private readonly record struct ValidationResult(string ItemContentId, string PriceContentId, string ItemProxyId, KioskItem KioskItem, MicroserviceInfo Identity);

    public async Task<KioskListResponse> KioskList()
    {
        var definedKioskContent = await _contractService.FetchFederationContentForKioskContracts();
        var personalKiosks = await _personalKioskCollection.GetByPlayer(_requestContext.UserId);
        var response = new KioskListResponse
        {
            kiosks = definedKioskContent.Select(k => new KioskResponse
            {
                kioskContentId = k.Kiosk.Id,
                itemContentType = k.Kiosk.ItemType,
                priceContentId = k.Kiosk.CurrencySymbol
            }).ToList()
        };

        if (personalKiosks is not null)
        {
            response.kiosks.Add(new KioskResponse
            {
                itemContentType = "",
                priceContentId = PlayerKioskHandler.PriceSymbol,
                kioskContentId = $"{PlayerKioskHandler.ModuleName}-{personalKiosks.KioskId}"
            });
        }

        return response;
    }
}